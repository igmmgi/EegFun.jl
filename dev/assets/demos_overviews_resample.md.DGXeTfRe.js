import{_ as i,o as t,c as a,aA as e}from"./chunks/framework.A7OkVGlh.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"demos/overviews/resample.md","filePath":"demos/overviews/resample.md","lastUpdated":null}'),n={name:"demos/overviews/resample.md"};function l(r,s,p,o,h,g){return t(),a("div",null,[...s[0]||(s[0]=[e(`<p>This demo shows how to change the sampling rate of EEG data through resampling.</p><h3 id="What-is-Resampling?" tabindex="-1">What is Resampling? <a class="header-anchor" href="#What-is-Resampling?" aria-label="Permalink to &quot;What is Resampling? {#What-is-Resampling?}&quot;">​</a></h3><p>Resampling changes the number of samples per second in your data:</p><ul><li><p><strong>Downsampling</strong>: Reduce sampling rate (e.g., 2048 Hz → 512 Hz)</p></li><li><p><strong>Upsampling</strong>: Increase sampling rate (e.g., 250 Hz → 500 Hz)</p></li><li><p><strong>Resample by factor</strong>: Divide or multiply by an integer factor</p></li></ul><h3 id="Why-Resample?" tabindex="-1">Why Resample? <a class="header-anchor" href="#Why-Resample?" aria-label="Permalink to &quot;Why Resample? {#Why-Resample?}&quot;">​</a></h3><p><strong>Downsampling benefits</strong>:</p><ul><li><p><strong>Reduce file size</strong>: Fewer samples = less disk space</p></li><li><p><strong>Speed up processing</strong>: Faster filtering, epoching, time-frequency analysis</p></li><li><p><strong>Match dataset requirements</strong>: Some analyses expect specific rates</p></li><li><p><strong>Remove unnecessary detail</strong>: Most ERP information is below 50 Hz</p></li></ul><p><strong>Upsampling use cases</strong>:</p><ul><li><p><strong>Match sampling rates</strong>: Combine datasets with different rates</p></li><li><p><strong>Synchronization</strong>: Align with external recordings</p></li><li><p><strong>Interpolation</strong>: Create smoother visualizations</p></li></ul><blockquote><p><strong>Note</strong>: Upsampling cannot add information that wasn&#39;t in the original signal - it only interpolates between existing samples.</p></blockquote><h3 id="The-Nyquist-Theorem" tabindex="-1">The Nyquist Theorem <a class="header-anchor" href="#The-Nyquist-Theorem" aria-label="Permalink to &quot;The Nyquist Theorem {#The-Nyquist-Theorem}&quot;">​</a></h3><p>The sampling rate must be <strong>at least 2× the highest frequency</strong> in your signal:</p><ul><li><p><strong>250 Hz sampling</strong> → Can represent frequencies up to 125 Hz</p></li><li><p><strong>500 Hz sampling</strong> → Can represent frequencies up to 250 Hz</p></li><li><p><strong>1000 Hz sampling</strong> → Can represent frequencies up to 500 Hz</p></li></ul><p><strong>For ERP research</strong>:</p><ul><li><p>Most ERP components are below 30-50 Hz</p></li><li><p><strong>250-500 Hz</strong> sampling is typically adequate</p></li><li><p>Higher rates needed for high-frequency oscillations (gamma: 30-100 Hz)</p></li></ul><h3 id="Anti-Aliasing" tabindex="-1">Anti-Aliasing <a class="header-anchor" href="#Anti-Aliasing" aria-label="Permalink to &quot;Anti-Aliasing {#Anti-Aliasing}&quot;">​</a></h3><p>When downsampling, <strong>always lowpass filter first</strong> to prevent aliasing:</p><p><strong>Bad practice</strong> (aliasing risk):</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dat_new </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Downsample by 4× WITHOUT filtering</span></span></code></pre></div><p><strong>Good practice</strong> (safe downsampling):</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># If original rate is 2048 Hz and downsampling to 512 Hz:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Filter at ~200 Hz (below new Nyquist of 256 Hz)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lowpass_filter!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dat_new </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Now safe to downsample</span></span></code></pre></div><p>EegFun&#39;s <code>resample</code> function applies anti-aliasing automatically, but it&#39;s still good practice to filter first if you have specific frequency requirements.</p><h3 id="Downsampling-Factors" tabindex="-1">Downsampling Factors <a class="header-anchor" href="#Downsampling-Factors" aria-label="Permalink to &quot;Downsampling Factors {#Downsampling-Factors}&quot;">​</a></h3><p>The demo shows downsampling by factors of 2 and 4:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dat_new </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Divide rate by 2 (e.g., 2048 → 1024 Hz)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dat_new </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Divide rate by 4 (e.g., 2048 → 512 Hz)</span></span></code></pre></div><p><strong>Common downsampling targets</strong>:</p><table tabindex="0"><thead><tr><th style="text-align:right;">Original Rate</th><th style="text-align:right;">Factor</th><th style="text-align:right;">Target Rate</th></tr></thead><tbody><tr><td style="text-align:right;">2048 Hz</td><td style="text-align:right;">4</td><td style="text-align:right;">512 Hz</td></tr><tr><td style="text-align:right;">2048 Hz</td><td style="text-align:right;">8</td><td style="text-align:right;">256 Hz</td></tr><tr><td style="text-align:right;">1024 Hz</td><td style="text-align:right;">4</td><td style="text-align:right;">256 Hz</td></tr><tr><td style="text-align:right;">1024 Hz</td><td style="text-align:right;">2</td><td style="text-align:right;">512 Hz</td></tr><tr><td style="text-align:right;">512 Hz</td><td style="text-align:right;">2</td><td style="text-align:right;">256 Hz</td></tr></tbody></table><h3 id="Trigger-Preservation" tabindex="-1">Trigger Preservation <a class="header-anchor" href="#Trigger-Preservation" aria-label="Permalink to &quot;Trigger Preservation {#Trigger-Preservation}&quot;">​</a></h3><p>The demo verifies that triggers are preserved during resampling:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trigger_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Original trigger count</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trigger_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dat_new)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Should match after resampling</span></span></code></pre></div><p>Trigger timing is automatically adjusted to match the new sampling rate.</p><h3 id="When-to-Resample" tabindex="-1">When to Resample <a class="header-anchor" href="#When-to-Resample" aria-label="Permalink to &quot;When to Resample {#When-to-Resample}&quot;">​</a></h3><p><strong>Resample early</strong> in your pipeline:</p><ol><li><p>Load raw data</p></li><li><p><strong>Resample</strong> (if needed)</p></li><li><p>Filter</p></li><li><p>Epoch</p></li><li><p>Analyze</p></li></ol><p>This minimizes processing time for subsequent steps.</p><p><strong>Don&#39;t resample after epoching</strong> unless necessary - it&#39;s more efficient to resample continuous data first.</p><h3 id="Workflow-Summary" tabindex="-1">Workflow Summary <a class="header-anchor" href="#Workflow-Summary" aria-label="Permalink to &quot;Workflow Summary {#Workflow-Summary}&quot;">​</a></h3><p>This demo demonstrates:</p><ol><li><p><strong>Load continuous data</strong> at original sampling rate</p></li><li><p><strong>Check current rate</strong> with <code>sample_rate()</code></p></li><li><p><strong>Downsample by factor</strong> (2× and 4×)</p></li><li><p><strong>Verify new rate</strong> matches expected value</p></li><li><p><strong>Verify triggers preserved</strong> with <code>trigger_count()</code></p></li></ol><h3 id="Best-Practices" tabindex="-1">Best Practices <a class="header-anchor" href="#Best-Practices" aria-label="Permalink to &quot;Best Practices {#Best-Practices}&quot;">​</a></h3><p><strong>Choose appropriate target rate</strong>:</p><ul><li><p><strong>250 Hz</strong>: Minimum for standard ERP work</p></li><li><p><strong>500 Hz</strong>: Good balance for most EEG applications</p></li><li><p><strong>1000+ Hz</strong>: Needed for high-frequency analyses</p></li></ul><p><strong>Filter before downsampling</strong>:</p><ul><li><p>Prevents aliasing artifacts</p></li><li><p>Use lowpass filter at ~80% of new Nyquist frequency</p></li></ul><p><strong>Document the change</strong>:</p><ul><li><p>Always note original and resampled rates in your analysis notes</p></li><li><p>Important for interpretation and reproducibility</p></li></ul>`,46)])])}const k=i(n,[["render",l]]);export{c as __pageData,k as default};
