import{_ as a,o as i,c as l,aA as t}from"./chunks/framework.A7OkVGlh.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"demos/overviews/channel_repair.md","filePath":"demos/overviews/channel_repair.md","lastUpdated":null}'),n={name:"demos/overviews/channel_repair.md"};function o(r,e,s,p,h,d){return i(),l("div",null,[...e[0]||(e[0]=[t('<p>This demo demonstrates channel interpolation methods for repairing bad electrodes using spatial interpolation techniques.</p><h3 id="What-is-Channel-Repair?" tabindex="-1">What is Channel Repair? <a class="header-anchor" href="#What-is-Channel-Repair?" aria-label="Permalink to &quot;What is Channel Repair? {#What-is-Channel-Repair?}&quot;">​</a></h3><p>Channel repair (interpolation) estimates the signal at bad electrodes using data from neighboring good channels. This preserves data quality while maintaining electrode count for spatial analyses.</p><h3 id="When-to-Repair-Channels" tabindex="-1">When to Repair Channels <a class="header-anchor" href="#When-to-Repair-Channels" aria-label="Permalink to &quot;When to Repair Channels {#When-to-Repair-Channels}&quot;">​</a></h3><p>Channel repair is appropriate when:</p><ul><li><p>Individual electrodes have poor contact/noisy signal</p></li><li><p>Isolated channels show excessive noise or artifacts</p></li><li><p>A small number of channels are affected while most data is clean</p></li><li><p>You need to maintain electrode count for spatial analyses (e.g., source localization)</p></li></ul><p><strong>Do not repair</strong> when:</p><ul><li><p>Too many channels are bad</p></li><li><p>The entire dataset is noisy</p></li><li><p>Bad channels cluster together spatially</p></li></ul><h3 id="Interpolation-Methods" tabindex="-1">Interpolation Methods <a class="header-anchor" href="#Interpolation-Methods" aria-label="Permalink to &quot;Interpolation Methods {#Interpolation-Methods}&quot;">​</a></h3><p><strong>Neighbor Interpolation</strong>:</p><ul><li><p>Weighted average of spatially nearby electrodes</p></li><li><p>Fast and computationally efficient</p></li><li><p>Good for isolated bad channels</p></li><li><p>Requires neighbor calculation based on distance threshold</p></li></ul><p><strong>Spherical Spline</strong>:</p><ul><li>Uses spherical spline functions to model scalp potential distribution</li></ul><h3 id="Best-Practices" tabindex="-1">Best Practices <a class="header-anchor" href="#Best-Practices" aria-label="Permalink to &quot;Best Practices {#Best-Practices}&quot;">​</a></h3><p><strong>Timing</strong>:</p><ul><li><p>Identify bad channels using quality metrics first</p></li><li><p>Repair before re-referencing (reference calculation needs all channels)</p></li><li><p>Repair before averaging or statistical analysis</p></li></ul><p><strong>Limits</strong>:</p><ul><li><p>Avoid interpolating too many channels</p></li><li><p>Consider rejecting datasets with an excessive number of bad channels</p></li></ul><p><strong>Validation</strong>:</p><ul><li><p>Visually verify repair quality (before/after comparison)</p></li><li><p>Check that interpolated channels match neighbors</p></li></ul><h2 id="Workflow-Summary" tabindex="-1">Workflow Summary <a class="header-anchor" href="#Workflow-Summary" aria-label="Permalink to &quot;Workflow Summary {#Workflow-Summary}&quot;">​</a></h2><p>This demo shows channel repair workflows:</p><h3 id="1.-Identify-Channels-to-Repair" tabindex="-1">1. Identify Channels to Repair <a class="header-anchor" href="#1.-Identify-Channels-to-Repair" aria-label="Permalink to &quot;1. Identify Channels to Repair {#1.-Identify-Channels-to-Repair}&quot;">​</a></h3><ul><li><p>Load and preprocess data</p></li><li><p>Select specific channels for demonstration</p></li><li><p>Verify channels exist in the dataset</p></li></ul><h3 id="2.-Calculate-Neighbor-Relationships" tabindex="-1">2. Calculate Neighbor Relationships <a class="header-anchor" href="#2.-Calculate-Neighbor-Relationships" aria-label="Permalink to &quot;2. Calculate Neighbor Relationships {#2.-Calculate-Neighbor-Relationships}&quot;">​</a></h3><ul><li><p>Compute spatial neighbors based on 3D electrode positions</p></li><li><p>Use distance threshold to define neighborhood</p></li><li><p>Required for neighbor interpolation method</p></li></ul><h3 id="3.-Apply-Interpolation" tabindex="-1">3. Apply Interpolation <a class="header-anchor" href="#3.-Apply-Interpolation" aria-label="Permalink to &quot;3. Apply Interpolation {#3.-Apply-Interpolation}&quot;">​</a></h3><ul><li><p>Test neighbor interpolation method</p></li><li><p>Test spherical spline method</p></li><li><p>Store original data for comparison</p></li></ul><h3 id="4.-Validate-Repair-Quality" tabindex="-1">4. Validate Repair Quality <a class="header-anchor" href="#4.-Validate-Repair-Quality" aria-label="Permalink to &quot;4. Validate Repair Quality {#4.-Validate-Repair-Quality}&quot;">​</a></h3><ul><li><p>Compare interpolated vs. original data</p></li><li><p>Verify that interpolation changed the data as expected</p></li><li><p>Use visual inspection to confirm successful repair</p></li></ul>',30)])])}const f=a(n,[["render",o]]);export{u as __pageData,f as default};
