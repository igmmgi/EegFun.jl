import{_ as l,C as r,o as p,c as d,j as i,a as o,E as s,aA as a,w as n}from"./chunks/framework.A7OkVGlh.js";const se=JSON.parse('{"title":"Core Types","description":"","frontmatter":{},"headers":[],"relativePath":"reference/types.md","filePath":"reference/types.md","lastUpdated":null}'),c={name:"reference/types.md"},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""};function Q(X,e,Y,Z,ee,ie){const t=r("Badge");return p(),d("div",null,[e[152]||(e[152]=i("h1",{id:"Core-Types",tabindex:"-1"},[o("Core Types "),i("a",{class:"header-anchor",href:"#Core-Types","aria-label":'Permalink to "Core Types {#Core-Types}"'},"​")],-1)),e[153]||(e[153]=i("p",null,"Data structures and type definitions in EegFun.jl.",-1)),e[154]||(e[154]=i("h2",{id:"Abstract-Types",tabindex:"-1"},[o("Abstract Types "),i("a",{class:"header-anchor",href:"#Abstract-Types","aria-label":'Permalink to "Abstract Types {#Abstract-Types}"'},"​")],-1)),i("details",u,[i("summary",null,[e[0]||(e[0]=i("a",{id:"EegFun.EegFunData",href:"#EegFun.EegFunData"},[i("span",{class:"jlbinding"},"EegFun.EegFunData")],-1)),e[1]||(e[1]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[3]||(e[3]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EegFunData</span></span></code></pre></div><p>Abstract supertype for all primary EegFun data and result structures.</p>',2)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[2]||(e[2]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",g,[i("summary",null,[e[4]||(e[4]=i("a",{id:"EegFun.EegData",href:"#EegFun.EegData"},[i("span",{class:"jlbinding"},"EegFun.EegData")],-1)),e[5]||(e[5]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[7]||(e[7]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EegData</span></span></code></pre></div><p>Abstract supertype for all EEG data structures.</p><p>This type represents the base interface for EEG data objects, providing a common interface for different data formats including continuous data, event-related potentials, and epoch-based data.</p>',3)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[6]||(e[6]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",m,[i("summary",null,[e[8]||(e[8]=i("a",{id:"EegFun.SingleDataFrameEeg",href:"#EegFun.SingleDataFrameEeg"},[i("span",{class:"jlbinding"},"EegFun.SingleDataFrameEeg")],-1)),e[9]||(e[9]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SingleDataFrameEeg</span></span></code></pre></div><p>Abstract type for EEG data stored in a single DataFrame.</p><p>This type represents EEG data where all samples are stored in a single DataFrame, typically used for continuous data or event-related potentials that have been averaged into a single time series.</p>',3)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[10]||(e[10]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",f,[i("summary",null,[e[12]||(e[12]=i("a",{id:"EegFun.MultiDataFrameEeg",href:"#EegFun.MultiDataFrameEeg"},[i("span",{class:"jlbinding"},"EegFun.MultiDataFrameEeg")],-1)),e[13]||(e[13]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[15]||(e[15]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MultiDataFrameEeg</span></span></code></pre></div><p>Abstract type for EEG data stored across multiple DataFrames.</p><p>This type represents EEG data where samples are distributed across multiple DataFrames, typically used for epoch-based data where each epoch is stored separately.</p>',3)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[14]||(e[14]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",h,[i("summary",null,[e[16]||(e[16]=i("a",{id:"EegFun.StatsResult",href:"#EegFun.StatsResult"},[i("span",{class:"jlbinding"},"EegFun.StatsResult")],-1)),e[17]||(e[17]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[19]||(e[19]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">StatsResult</span></span></code></pre></div><p>Abstract type for statistical test results. All statistical test results share common fields:</p><ul><li><p><code>test_info::TestInfo</code>: Test configuration and parameters</p></li><li><p><code>data::Vector{ErpData}</code>: Grand average ERPs for conditions 1 and 2</p></li><li><p><code>stat_matrix::StatMatrix</code>: T-statistics and optionally p-values</p></li><li><p><code>masks::Masks</code>: Significance masks for positive and negative effects</p></li><li><p><code>electrodes::Vector{Symbol}</code>: Electrode labels</p></li><li><p><code>time_points::Vector{Float64}</code>: Time points in seconds</p></li><li><p><code>critical_t</code>: Critical t-values (type varies by test method)</p></li></ul>',3)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[18]||(e[18]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[155]||(e[155]=i("h2",{id:"Data-Container-Types",tabindex:"-1"},[o("Data Container Types "),i("a",{class:"header-anchor",href:"#Data-Container-Types","aria-label":'Permalink to "Data Container Types {#Data-Container-Types}"'},"​")],-1)),i("details",y,[i("summary",null,[e[20]||(e[20]=i("a",{id:"EegFun.AnalysisInfo",href:"#EegFun.AnalysisInfo"},[i("span",{class:"jlbinding"},"EegFun.AnalysisInfo")],-1)),e[21]||(e[21]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[23]||(e[23]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AnalysisInfo</span></span></code></pre></div><p>Stores metadata about data preprocessing and analysis parameters.</p><p>This type contains information about how the EEG data has been processed, including filtering parameters, reference information, and other analysis settings that affect the interpretation of the data.</p><p><strong>Fields</strong></p><ul><li><p><code>reference::Symbol</code>: Reference type used (e.g., :avg, :mastoid, :none)</p></li><li><p><code>hp_filter::Float64</code>: High-pass filter cutoff in Hz (0.0 if none)</p></li><li><p><code>lp_filter::Float64</code>: Low-pass filter cutoff in Hz (0.0 if none)</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[22]||(e[22]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",b,[i("summary",null,[e[24]||(e[24]=i("a",{id:"EegFun.ContinuousData",href:"#EegFun.ContinuousData"},[i("span",{class:"jlbinding"},"EegFun.ContinuousData")],-1)),e[25]||(e[25]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[27]||(e[27]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ContinuousData</span></span></code></pre></div><p>Stores continuous EEG data with associated layout and analysis information.</p><p>This type represents continuous EEG recordings where all time points are stored in a single DataFrame. The data typically includes time series for each electrode channel along with metadata columns.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename</p></li><li><p><code>data::DataFrame</code>: DataFrame containing continuous data (without file column)</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the data in Hz</p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[26]||(e[26]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",E,[i("summary",null,[e[28]||(e[28]=i("a",{id:"EegFun.ErpData",href:"#EegFun.ErpData"},[i("span",{class:"jlbinding"},"EegFun.ErpData")],-1)),e[29]||(e[29]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[31]||(e[31]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ErpData</span></span></code></pre></div><p>Stores event-related potential data with associated layout and analysis information.</p><p>This type represents averaged event-related potentials where multiple epochs have been averaged together into a single time series. The data includes the averaged ERP waveform for each electrode channel.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename</p></li><li><p><code>condition::Int64</code>: Condition number</p></li><li><p><code>condition_name::String</code>: Name of the condition</p></li><li><p><code>data::DataFrame</code>: DataFrame containing averaged ERP data (without condition/condition_name/n_epochs columns)</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the data in Hz</p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li><li><p><code>n_epochs::Int64</code>: Number of epochs that were averaged together</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[30]||(e[30]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",T,[i("summary",null,[e[32]||(e[32]=i("a",{id:"EegFun.EpochData",href:"#EegFun.EpochData"},[i("span",{class:"jlbinding"},"EegFun.EpochData")],-1)),e[33]||(e[33]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[35]||(e[35]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EpochData</span></span></code></pre></div><p>Stores epoch-based EEG data with associated layout and analysis information.</p><p>This type represents EEG data organized into individual epochs, where each epoch is stored as a separate DataFrame. This format is useful for event-related potential analysis and other epoch-based processing.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename (constant across all epochs)</p></li><li><p><code>condition::Int64</code>: Condition number (constant across all epochs)</p></li><li><p><code>condition_name::String</code>: Name of the condition (constant across all epochs)</p></li><li><p><code>data::Vector{DataFrame}</code>: Vector of DataFrames, one for each epoch (without condition/condition_name/file columns; epoch column remains for original numbering)</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the data in Hz</p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[34]||(e[34]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_,[i("summary",null,[e[36]||(e[36]=i("a",{id:"EegFun.TimeFreqData",href:"#EegFun.TimeFreqData"},[i("span",{class:"jlbinding"},"EegFun.TimeFreqData")],-1)),e[37]||(e[37]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[39]||(e[39]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TimeFreqData</span></span></code></pre></div><p>Stores time-frequency analysis results for a single condition/average.</p><p>This type represents time-frequency power and phase data where all time-frequency points are stored in DataFrames with columns for time, frequency, and each electrode channel. Suitable for averaged TF representations.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename</p></li><li><p><code>condition::Int64</code>: Condition number</p></li><li><p><code>condition_name::String</code>: Name of the condition</p></li><li><p><code>data_power::DataFrame</code>: DataFrame with columns: time, freq, [electrode channels...] containing power values</p></li><li><p><code>data_phase::DataFrame</code>: DataFrame with columns: time, freq, [electrode channels...] containing phase values (radians)</p></li><li><p><code>data::DataFrame</code>: Alias for <code>data_power</code> (for backward compatibility)</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the original data in Hz</p></li><li><p><code>method::Symbol</code>: Analysis method (<code>:wavelet</code>, <code>:superlet</code>, <code>:multitaper</code>, <code>:spectrum</code>, <code>:hanning_fixed</code>, <code>:hanning_adaptive</code>)</p></li><li><p><code>baseline::Union{BaselineInfo,Nothing}</code>: Baseline correction information (if applied)</p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[38]||(e[38]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",k,[i("summary",null,[e[40]||(e[40]=i("a",{id:"EegFun.TimeFreqEpochData",href:"#EegFun.TimeFreqEpochData"},[i("span",{class:"jlbinding"},"EegFun.TimeFreqEpochData")],-1)),e[41]||(e[41]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[43]||(e[43]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TimeFreqEpochData</span></span></code></pre></div><p>Stores time-frequency analysis results with individual trials preserved.</p><p>This type represents time-frequency power and phase data organized into individual trials, where each trial is stored as a separate DataFrame. Each DataFrame contains columns for time, frequency, and each electrode channel.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename (constant across all trials)</p></li><li><p><code>condition::Int64</code>: Condition number (constant across all trials)</p></li><li><p><code>condition_name::String</code>: Name of the condition (constant across all trials)</p></li><li><p><code>data_power::Vector{DataFrame}</code>: Vector of DataFrames, one per trial (columns: time, freq, [electrodes...]) containing power values</p></li><li><p><code>data_phase::Vector{DataFrame}</code>: Vector of DataFrames, one per trial (columns: time, freq, [electrodes...]) containing phase values (radians)</p></li><li><p><code>data::Vector{DataFrame}</code>: Alias for <code>data_power</code> (for backward compatibility)</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the original data in Hz</p></li><li><p><code>method::Symbol</code>: Analysis method (<code>:wavelet</code>, <code>:superlet</code>, <code>:multitaper</code>, <code>:spectrum</code>, <code>:hanning_fixed</code>, <code>:hanning_adaptive</code>)</p></li><li><p><code>baseline::Union{BaselineInfo,Nothing}</code>: Baseline correction information (if applied)</p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[42]||(e[42]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",F,[i("summary",null,[e[44]||(e[44]=i("a",{id:"EegFun.SpectrumData",href:"#EegFun.SpectrumData"},[i("span",{class:"jlbinding"},"EegFun.SpectrumData")],-1)),e[45]||(e[45]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[47]||(e[47]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SpectrumData</span></span></code></pre></div><p>Stores power spectrum analysis results (frequency domain, no time dimension).</p><p>This type represents power spectral density data computed using Welch&#39;s method or other spectral estimation techniques. The data is stored in a DataFrame with frequency values and power for each electrode channel.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename</p></li><li><p><code>condition::Int64</code>: Condition number</p></li><li><p><code>condition_name::String</code>: Name of the condition</p></li><li><p><code>data::DataFrame</code>: DataFrame with columns: freq, [electrode channels...] containing power spectral density (μV²/Hz)</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the original data in Hz</p></li><li><p><code>method::Symbol</code>: Analysis method (<code>:welch</code>, <code>:multitaper</code>, etc.)</p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[46]||(e[46]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[156]||(e[156]=i("h2",{id:"Layout-Types",tabindex:"-1"},[o("Layout Types "),i("a",{class:"header-anchor",href:"#Layout-Types","aria-label":'Permalink to "Layout Types {#Layout-Types}"'},"​")],-1)),i("details",v,[i("summary",null,[e[48]||(e[48]=i("a",{id:"EegFun.Layout",href:"#EegFun.Layout"},[i("span",{class:"jlbinding"},"EegFun.Layout")],-1)),e[49]||(e[49]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[51]||(e[51]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Layout</span></span></code></pre></div><p>Stores electrode layout information and spatial relationships.</p><p>This type contains the complete electrode layout information including electrode positions in various coordinate systems (polar, 2D Cartesian, 3D Cartesian) and neighbor relationships for spatial operations.</p><p><strong>Fields</strong></p><ul><li><p><code>data::DataFrame</code>: DataFrame containing layout information with metadata groups</p></li><li><p><code>neighbours::Union{Nothing, OrderedDict{Symbol, Neighbours}}</code>: Dictionary of neighbours for each electrode</p></li><li><p><code>criterion::Union{Nothing, Float64}</code>: Distance criterion for neighbour calculation in mm</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[50]||(e[50]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",j,[i("summary",null,[e[52]||(e[52]=i("a",{id:"EegFun.Neighbours",href:"#EegFun.Neighbours"},[i("span",{class:"jlbinding"},"EegFun.Neighbours")],-1)),e[53]||(e[53]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[55]||(e[55]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Neighbours</span></span></code></pre></div><p>Stores spatial neighbor information for an electrode in layout-based operations.</p><p>This type contains information about neighboring electrodes for spatial interpolation, artifact detection, and other layout-dependent operations. The distances and weights are typically calculated based on electrode positions in 2D or 3D space.</p><p><strong>Fields</strong></p><ul><li><p><code>channels::Vector{Symbol}</code>: List of neighboring channel labels</p></li><li><p><code>distances::Vector{Float64}</code>: Distances to each neighbor in mm</p></li><li><p><code>weights::Vector{Float64}</code>: Interpolation weights for each neighbor</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[54]||(e[54]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[157]||(e[157]=i("h2",{id:"Epoch-Configuration",tabindex:"-1"},[o("Epoch Configuration "),i("a",{class:"header-anchor",href:"#Epoch-Configuration","aria-label":'Permalink to "Epoch Configuration {#Epoch-Configuration}"'},"​")],-1)),i("details",C,[i("summary",null,[e[56]||(e[56]=i("a",{id:"EegFun.EpochCondition",href:"#EegFun.EpochCondition"},[i("span",{class:"jlbinding"},"EegFun.EpochCondition")],-1)),e[57]||(e[57]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[59]||(e[59]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EpochCondition</span></span></code></pre></div><p>Defines parameters for extracting epochs for a specific experimental condition.</p><p>This type specifies the criteria for identifying and extracting epochs from continuous EEG data based on trigger sequences and timing constraints. It supports complex trigger patterns and timing relationships between events.</p><p><strong>Fields</strong></p><ul><li><p><code>name::String</code>: Descriptive condition name for identification</p></li><li><p><code>trigger_sequences::Vector{Vector{Union{Int,Symbol,UnitRange{Int}}}}</code>: Trigger sequences to match (e.g., [[1, 2, 3]], [[1, :any, 3]], [[1:5], [10:15]])</p></li><li><p><code>reference_index::Int</code>: Which trigger position is t=0 (1-based, default: 1)</p></li><li><p><code>timing_pairs::Union{Nothing,Vector{Tuple{Int,Int}}}</code>: Which trigger pairs to apply min/max intervals to (optional, default: nothing)</p></li><li><p><code>min_interval::Union{Nothing,Float64}</code>: Minimum time between specified trigger pairs in seconds (optional, default: nothing)</p></li><li><p><code>max_interval::Union{Nothing,Float64}</code>: Maximum time between specified trigger pairs in seconds (optional, default: nothing)</p></li><li><p><code>after::Union{Nothing,Int}</code>: Only search for sequences after this trigger value (optional, default: nothing)</p></li><li><p><code>before::Union{Nothing,Int}</code>: Only search for sequences before this trigger value (optional, default: nothing)</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[58]||(e[58]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[158]||(e[158]=i("h2",{id:"ICA-Types",tabindex:"-1"},[o("ICA Types "),i("a",{class:"header-anchor",href:"#ICA-Types","aria-label":'Permalink to "ICA Types {#ICA-Types}"'},"​")],-1)),i("details",S,[i("summary",null,[e[60]||(e[60]=i("a",{id:"EegFun.IcaPrms",href:"#EegFun.IcaPrms"},[i("span",{class:"jlbinding"},"EegFun.IcaPrms")],-1)),e[61]||(e[61]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[63]||(e[63]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IcaPrms</span></span></code></pre></div><p>Parameters for Independent Component Analysis (ICA) decomposition.</p><p>This type contains all the parameters needed to configure ICA decomposition of EEG data, including learning rates, convergence criteria, and algorithm specific settings.</p><p><strong>Fields</strong></p><ul><li><p><code>l_rate::Float64</code>: Learning rate for the ICA algorithm</p></li><li><p><code>max_iter::Int</code>: Maximum number of iterations for convergence</p></li><li><p><code>w_change::Float64</code>: Weight change threshold for convergence</p></li><li><p><code>anneal_deg::Float64</code>: Annealing degree for temperature scheduling</p></li><li><p><code>anneal_step::Float64</code>: Annealing step size for temperature updates</p></li><li><p><code>blowup::Float64</code>: Blowup factor for numerical stability</p></li><li><p><code>blowup_fac::Float64</code>: Blowup factor for algorithm stability</p></li><li><p><code>max_weight::Float64</code>: Maximum allowed weight value</p></li><li><p><code>restart_factor::Float64</code>: Factor for restarting stuck algorithms</p></li><li><p><code>degconst::Float64</code>: Degree constant for spherical coordinates</p></li><li><p><code>default_stop::Float64</code>: Default stopping criterion threshold</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[62]||(e[62]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",A,[i("summary",null,[e[64]||(e[64]=i("a",{id:"EegFun.InfoIca",href:"#EegFun.InfoIca"},[i("span",{class:"jlbinding"},"EegFun.InfoIca")],-1)),e[65]||(e[65]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[67]||(e[67]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InfoIca</span></span></code></pre></div><p>Stores ICA analysis results and decomposition information.</p><p>This type contains the complete results of ICA decomposition including the unmixing and mixing matrices, component statistics, and metadata about the decomposition process.</p><p><strong>Fields</strong></p><ul><li><p><code>unmixing::Matrix{Float64}</code>: Unmixing matrix (sources = unmixing × data)</p></li><li><p><code>mixing::Matrix{Float64}</code>: Mixing matrix (data = mixing × sources)</p></li><li><p><code>sphere::Matrix{Float64}</code>: Sphering matrix for data preprocessing</p></li><li><p><code>variance::Vector{Float64}</code>: Variance explained by each component</p></li><li><p><code>scale::Float64</code>: Scaling factor applied to the data</p></li><li><p><code>mean::Vector{Float64}</code>: Mean vector subtracted from the data</p></li><li><p><code>ica_label::Vector{Symbol}</code>: Component labels (e.g., [:IC1, :IC2, ...])</p></li><li><p><code>layout::Layout</code>: Layout information for the ICA components (contains channel labels)</p></li><li><p><code>removed_activations::OrderedDict{Int, Matrix{Float64}}</code>: Removed component activations by epoch</p></li><li><p><code>kurtosis_signs::Vector{Bool}</code>: Boolean vector indicating if each component is sub-Gaussian (true = sub-Gaussian, false = super-Gaussian). For regular Infomax, all components are super-Gaussian (all false).</p></li><li><p><code>filename::String</code>: Filename of the input data file used to generate this ICA result</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[66]||(e[66]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[159]||(e[159]=i("h2",{id:"Statistics-Types",tabindex:"-1"},[o("Statistics Types "),i("a",{class:"header-anchor",href:"#Statistics-Types","aria-label":'Permalink to "Statistics Types {#Statistics-Types}"'},"​")],-1)),i("details",x,[i("summary",null,[e[68]||(e[68]=i("a",{id:"EegFun.AnalysisData",href:"#EegFun.AnalysisData"},[i("span",{class:"jlbinding"},"EegFun.AnalysisData")],-1)),e[69]||(e[69]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[71]||(e[71]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AnalysisData</span></span></code></pre></div><p>Stores core analysis data for statistical tests.</p><p><strong>Fields</strong></p><ul><li><p><code>design::Symbol</code>: Design type - <code>:paired</code> or <code>:independent</code></p></li><li><p><code>data::Vector{Array{Float64, 3}}</code>: Data for conditions 1 and 2 [condition1, condition2], each [participants × electrodes × time]</p></li><li><p><code>time_points::Vector{Float64}</code>: Time points in seconds for the analysis window</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[70]||(e[70]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",D,[i("summary",null,[e[72]||(e[72]=i("a",{id:"EegFun.StatisticalData",href:"#EegFun.StatisticalData"},[i("span",{class:"jlbinding"},"EegFun.StatisticalData")],-1)),e[73]||(e[73]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[75]||(e[75]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">StatisticalData</span></span></code></pre></div><p>Stores prepared data for statistical tests (both permutation and analytic tests).</p><p><strong>Fields</strong></p><ul><li><p><code>data::Vector{ErpData}</code>: Grand average ERPs for conditions 1 and 2 (for visualization/storage)</p></li><li><p><code>analysis::AnalysisData</code>: Core analysis data (design, data arrays, time points)</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[74]||(e[74]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",I,[i("summary",null,[e[76]||(e[76]=i("a",{id:"EegFun.Cluster",href:"#EegFun.Cluster"},[i("span",{class:"jlbinding"},"EegFun.Cluster")],-1)),e[77]||(e[77]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[79]||(e[79]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Cluster</span></span></code></pre></div><p>Stores information about a single cluster found in the thresholded data.</p><p><strong>Fields</strong></p><ul><li><p><code>id::Int</code>: Unique cluster identifier</p></li><li><p><code>electrodes::Vector{Symbol}</code>: Electrode labels in this cluster</p></li><li><p><code>time_indices::Vector{Int}</code>: Time point indices in this cluster</p></li><li><p><code>time_range::Tuple{Float64, Float64}</code>: Time range in seconds (start, end)</p></li><li><p><code>cluster_stat::Float64</code>: Cluster-level statistic (e.g., sum of t-values)</p></li><li><p><code>p_value::Float64</code>: P-value from permutation test</p></li><li><p><code>is_significant::Bool</code>: Whether cluster is significant (p &lt; alpha)</p></li><li><p><code>polarity::Symbol</code>: <code>:positive</code> or <code>:negative</code></p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[78]||(e[78]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",V,[i("summary",null,[e[80]||(e[80]=i("a",{id:"EegFun.ClusterInfo",href:"#EegFun.ClusterInfo"},[i("span",{class:"jlbinding"},"EegFun.ClusterInfo")],-1)),e[81]||(e[81]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[83]||(e[83]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ClusterInfo</span></span></code></pre></div><p>Stores cluster-specific parameters for cluster permutation tests.</p><p><strong>Fields</strong></p><ul><li><p><code>threshold_method::Symbol</code>: <code>:parametric</code>, <code>:nonparametric_individual</code>, or <code>:nonparametric_common</code></p></li><li><p><code>cluster_type::Symbol</code>: <code>:spatial</code>, <code>:temporal</code>, or <code>:spatiotemporal</code></p></li><li><p><code>n_permutations::Int</code>: Number of permutations performed</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[82]||(e[82]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",P,[i("summary",null,[e[84]||(e[84]=i("a",{id:"EegFun.Clusters",href:"#EegFun.Clusters"},[i("span",{class:"jlbinding"},"EegFun.Clusters")],-1)),e[85]||(e[85]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[87]||(e[87]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Clusters</span></span></code></pre></div><p>Stores positive and negative clusters from cluster permutation tests.</p><p><strong>Fields</strong></p><ul><li><p><code>positive::Vector{Cluster}</code>: Positive clusters</p></li><li><p><code>negative::Vector{Cluster}</code>: Negative clusters</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[86]||(e[86]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",N,[i("summary",null,[e[88]||(e[88]=i("a",{id:"EegFun.TestInfo",href:"#EegFun.TestInfo"},[i("span",{class:"jlbinding"},"EegFun.TestInfo")],-1)),e[89]||(e[89]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[91]||(e[91]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TestInfo</span></span></code></pre></div><p>Stores test configuration and parameters.</p><p><strong>Fields</strong></p><ul><li><p><code>type::Symbol</code>: Design/test type - <code>:paired</code> or <code>:independent</code></p></li><li><p><code>df::Float64</code>: Degrees of freedom</p></li><li><p><code>alpha::Float64</code>: Significance threshold</p></li><li><p><code>tail::Symbol</code>: Test tail - <code>:both</code>, <code>:left</code>, or <code>:right</code></p></li><li><p><code>correction_method::Symbol</code>: Multiple comparison correction - <code>:none</code>, <code>:bonferroni</code>, or <code>:cluster_permutation</code></p></li><li><p><code>cluster_info::Union{ClusterInfo, Nothing}</code>: Cluster-specific info (nothing for analytic tests)</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[90]||(e[90]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",w,[i("summary",null,[e[92]||(e[92]=i("a",{id:"EegFun.StatMatrix",href:"#EegFun.StatMatrix"},[i("span",{class:"jlbinding"},"EegFun.StatMatrix")],-1)),e[93]||(e[93]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[95]||(e[95]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">StatMatrix</span></span></code></pre></div><p>Stores t-statistics and p-values matrices.</p><p><strong>Fields</strong></p><ul><li><p><code>t::Array{Float64, 2}</code>: T-statistics [electrodes × time]</p></li><li><p><code>p::Union{Array{Float64, 2}, Nothing}</code>: P-values [electrodes × time], or <code>nothing</code> for cluster permutation</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[94]||(e[94]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",R,[i("summary",null,[e[96]||(e[96]=i("a",{id:"EegFun.Masks",href:"#EegFun.Masks"},[i("span",{class:"jlbinding"},"EegFun.Masks")],-1)),e[97]||(e[97]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[99]||(e[99]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Masks</span></span></code></pre></div><p>Stores significance masks for positive and negative effects.</p><p><strong>Fields</strong></p><ul><li><p><code>positive::BitArray{2}</code>: Positive significant points [electrodes × time]</p></li><li><p><code>negative::BitArray{2}</code>: Negative significant points [electrodes × time]</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[98]||(e[98]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",O,[i("summary",null,[e[100]||(e[100]=i("a",{id:"EegFun.PermutationDistribution",href:"#EegFun.PermutationDistribution"},[i("span",{class:"jlbinding"},"EegFun.PermutationDistribution")],-1)),e[101]||(e[101]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[103]||(e[103]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PermutationDistribution</span></span></code></pre></div><p>Stores the null distribution of maximum cluster statistics from permutations.</p><p><strong>Fields</strong></p><ul><li><p><code>positive::Vector{Float64}</code>: Maximum positive cluster stats from each permutation</p></li><li><p><code>negative::Vector{Float64}</code>: Maximum negative cluster stats from each permutation</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[102]||(e[102]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",q,[i("summary",null,[e[104]||(e[104]=i("a",{id:"EegFun.PermutationResult",href:"#EegFun.PermutationResult"},[i("span",{class:"jlbinding"},"EegFun.PermutationResult")],-1)),e[105]||(e[105]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[107]||(e[107]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PermutationResult</span></span></code></pre></div><p>Stores complete results from a cluster-based permutation test.</p><p><strong>Fields</strong></p><ul><li><p><code>test_info::TestInfo</code>: Test configuration and parameters (includes ClusterInfo)</p></li><li><p><code>data::Vector{ErpData}</code>: Grand average ERPs for conditions 1 and 2 (for visualization)</p></li><li><p><code>stat_matrix::StatMatrix</code>: T-statistics matrix. Note: p is <code>nothing</code> for cluster permutation</p></li><li><p><code>masks::Masks</code>: Significance masks for positive and negative effects</p></li><li><p><code>clusters::Clusters</code>: Positive and negative clusters</p></li><li><p><code>permutation_distribution::PermutationDistribution</code>: Null distribution of max cluster stats</p></li><li><p><code>electrodes::Vector{Symbol}</code>: Electrode labels</p></li><li><p><code>time_points::Vector{Float64}</code>: Time points in seconds</p></li><li><p><code>critical_t::Union{Array{Float64, 2}, Tuple{Float64, Float64}, Tuple{Array{Float64, 2}, Array{Float64, 2}}}</code>: Critical t-values used</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[106]||(e[106]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",M,[i("summary",null,[e[108]||(e[108]=i("a",{id:"EegFun.AnalyticResult",href:"#EegFun.AnalyticResult"},[i("span",{class:"jlbinding"},"EegFun.AnalyticResult")],-1)),e[109]||(e[109]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[111]||(e[111]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AnalyticResult</span></span></code></pre></div><p>Stores results from an analytic (parametric) t-test without permutation.</p><p><strong>Fields</strong></p><ul><li><p><code>test_info::TestInfo</code>: Test configuration (type, df, alpha, tail, correction_method, cluster_info=nothing)</p></li><li><p><code>data::Vector{ErpData}</code>: Grand average ERPs for conditions 1 and 2 (for visualization/storage)</p></li><li><p><code>stat_matrix::StatMatrix</code>: Statistical results containing <code>t</code> (t-statistics) and <code>p</code> (p-values) [electrodes × time]</p></li><li><p><code>masks::Masks</code>: Significance masks containing <code>positive</code> and <code>negative</code> significant points [electrodes × time]</p></li><li><p><code>electrodes::Vector{Symbol}</code>: Electrode labels</p></li><li><p><code>time_points::Vector{Float64}</code>: Time points in seconds</p></li><li><p><code>critical_t::Float64</code>: Critical t-value for significance (uniform across all points)</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[110]||(e[110]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[160]||(e[160]=i("h2",{id:"Decoding-Types",tabindex:"-1"},[o("Decoding Types "),i("a",{class:"header-anchor",href:"#Decoding-Types","aria-label":'Permalink to "Decoding Types {#Decoding-Types}"'},"​")],-1)),i("details",G,[i("summary",null,[e[112]||(e[112]=i("a",{id:"EegFun.DecodingParameters",href:"#EegFun.DecodingParameters"},[i("span",{class:"jlbinding"},"EegFun.DecodingParameters")],-1)),e[113]||(e[113]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[115]||(e[115]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DecodingParameters</span></span></code></pre></div><p>Stores parameters used for decoding analysis.</p><p><strong>Fields</strong></p><ul><li><p><code>chance_level::Float64</code>: Expected chance-level performance (e.g., 0.5 for binary, 1/n_classes for n-class)</p></li><li><p><code>n_iterations::Int64</code>: Number of iterations/permutations performed</p></li><li><p><code>n_folds::Int64</code>: Number of cross-validation folds</p></li><li><p><code>class_coding::Symbol</code>: Multi-class coding scheme (<code>:one_vs_one</code>, <code>:one_vs_all</code>, <code>:binary</code>)</p></li><li><p><code>n_classes::Int64</code>: Number of classes/conditions being decoded</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[114]||(e[114]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",L,[i("summary",null,[e[116]||(e[116]=i("a",{id:"EegFun.DecodedData",href:"#EegFun.DecodedData"},[i("span",{class:"jlbinding"},"EegFun.DecodedData")],-1)),e[117]||(e[117]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[119]||(e[119]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DecodedData</span></span></code></pre></div><p>Stores MVPA/decoding analysis results for a single participant.</p><p>This type represents the results of multivariate pattern classification analysis, including classification accuracy over time, confusion matrices, and metadata about the analysis parameters.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename</p></li><li><p><code>condition_names::Vector{String}</code>: Names of conditions/bins being decoded</p></li><li><p><code>times::Vector{Float64}</code>: Time points in seconds where decoding was performed</p></li><li><p><code>average_score::Vector{Float64}</code>: Average classification accuracy at each time point</p></li><li><p><code>channels::Vector{Symbol}</code>: Channel names used in the analysis</p></li><li><p><code>parameters::DecodingParameters</code>: Decoding analysis parameters (chance_level, n_iterations, n_folds, class_coding, n_classes)</p></li><li><p><code>stderror::Union{Vector{Float64}, Nothing}</code>: Standard error of accuracy, or <code>nothing</code></p></li><li><p><code>confusion_matrix::Union{Array{Float64, 3}, Nothing}</code>: Confusion matrices [time × true_class × predicted_class], or <code>nothing</code></p></li><li><p><code>raw_predictions::Union{Array{Float64, 4}, Nothing}</code>: Raw predictions [iteration × fold × time × class], or <code>nothing</code></p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[118]||(e[118]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[161]||(e[161]=i("h2",{id:"RSA-Types",tabindex:"-1"},[o("RSA Types "),i("a",{class:"header-anchor",href:"#RSA-Types","aria-label":'Permalink to "RSA Types {#RSA-Types}"'},"​")],-1)),i("details",U,[i("summary",null,[e[120]||(e[120]=i("a",{id:"EegFun.NoiseCeiling",href:"#EegFun.NoiseCeiling"},[i("span",{class:"jlbinding"},"EegFun.NoiseCeiling")],-1)),e[121]||(e[121]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[123]||(e[123]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NoiseCeiling</span></span></code></pre></div><p>Stores noise ceiling estimates for RSA analysis.</p><p>The noise ceiling quantifies the maximum correlation that an ideal model could achieve with the observed neural data, given the noise and variability in the measurements. This is computed using leave-one-out cross-validation across participants (Nili et al., 2014).</p><p><strong>Fields</strong></p><ul><li><p><code>lower_bound::Vector{Float64}</code>: Lower bound of noise ceiling at each time point [time]</p><ul><li><p>Computed as correlation between each left-out participant and the average of remaining participants</p></li><li><p>Conservative estimate (underestimates true ceiling)</p></li></ul></li><li><p><code>upper_bound::Vector{Float64}</code>: Upper bound of noise ceiling at each time point [time]</p><ul><li><p>Computed as correlation between each left-out participant and the average of all participants</p></li><li><p>Liberal estimate (overestimates true ceiling)</p></li></ul></li><li><p><code>n_participants::Int</code>: Number of participants used in computation</p></li></ul><p><strong>References</strong></p><p>Nili, H., Wingfield, C., Walther, A., Su, L., Marslen-Wilson, W., &amp; Kriegeskorte, N. (2014). A toolbox for representational similarity analysis. PLoS computational biology, 10(4), e1003553.</p>',7)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[122]||(e[122]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",z,[i("summary",null,[e[124]||(e[124]=i("a",{id:"EegFun.RsaData",href:"#EegFun.RsaData"},[i("span",{class:"jlbinding"},"EegFun.RsaData")],-1)),e[125]||(e[125]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[127]||(e[127]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RsaData</span></span></code></pre></div><p>Stores RSA analysis results for a single participant.</p><p>This type represents the results of Representational Similarity Analysis, including Representational Dissimilarity Matrices (RDMs) computed at each time point, correlations with model RDMs, and metadata about the analysis.</p><p><strong>Fields</strong></p><ul><li><p><code>file::String</code>: Source filename</p></li><li><p><code>condition_names::Vector{String}</code>: Names of conditions/bins analyzed</p></li><li><p><code>times::Vector{Float64}</code>: Time points in seconds where RDMs were computed</p></li><li><p><code>rdm::Array{Float64, 3}</code>: Representational Dissimilarity Matrices [time × condition × condition]</p></li><li><p><code>dissimilarity_measure::Symbol</code>: Measure used (:correlation, :euclidean, :mahalanobis, etc.)</p></li><li><p><code>channels::Vector{Symbol}</code>: Channel names used in the analysis</p></li><li><p><code>layout::Layout</code>: Layout object containing electrode positioning information</p></li><li><p><code>sample_rate::Int64</code>: Sample rate of the original data in Hz</p></li><li><p><code>model_correlations::Union{Array{Float64, 2}, Nothing}</code>: Correlations with model RDMs [time × model]</p></li><li><p><code>model_names::Union{Vector{String}, Nothing}</code>: Names of models compared (if any)</p></li><li><p><code>p_values::Union{Array{Float64, 2}, Nothing}</code>: P-values for model correlations [time × model]</p></li><li><p><code>noise_ceiling::Union{NoiseCeiling, Nothing}</code>: Noise ceiling estimates, or <code>nothing</code></p></li><li><p><code>analysis_info::AnalysisInfo</code>: Analysis information and preprocessing metadata</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[126]||(e[126]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[162]||(e[162]=i("h2",{id:"Pipeline-Configuration-Types",tabindex:"-1"},[o("Pipeline Configuration Types "),i("a",{class:"header-anchor",href:"#Pipeline-Configuration-Types","aria-label":'Permalink to "Pipeline Configuration Types {#Pipeline-Configuration-Types}"'},"​")],-1)),i("details",B,[i("summary",null,[e[128]||(e[128]=i("a",{id:"EegFun.FilterSection",href:"#EegFun.FilterSection"},[i("span",{class:"jlbinding"},"EegFun.FilterSection")],-1)),e[129]||(e[129]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[131]||(e[131]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FilterSection</span></span></code></pre></div><p>Configuration for a single filter (highpass, lowpass, etc.).</p><p><strong>Fields</strong></p><ul><li><p><code>apply::Bool</code>: Whether to apply this filter</p></li><li><p><code>type::String</code>: Filter type (&quot;hp&quot;=highpass, &quot;lp&quot;=lowpass)</p></li><li><p><code>freq::Float64</code>: Cutoff frequency in Hz</p></li><li><p><code>func::String</code>: Filter function (&quot;filt&quot; or &quot;filtfilt&quot;)</p></li><li><p><code>method::String</code>: Filter method (&quot;iir&quot; or &quot;fir&quot;)</p></li><li><p><code>order::Int</code>: Filter order</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[130]||(e[130]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",H,[i("summary",null,[e[132]||(e[132]=i("a",{id:"EegFun.FilterConfig",href:"#EegFun.FilterConfig"},[i("span",{class:"jlbinding"},"EegFun.FilterConfig")],-1)),e[133]||(e[133]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[135]||(e[135]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FilterConfig</span></span></code></pre></div><p>Configuration for all filters used in preprocessing.</p><p><strong>Fields</strong></p><ul><li><p><code>highpass::FilterSection</code>: Highpass filter settings</p></li><li><p><code>lowpass::FilterSection</code>: Lowpass filter settings</p></li><li><p><code>ica_highpass::FilterSection</code>: Highpass filter for ICA data</p></li><li><p><code>ica_lowpass::FilterSection</code>: Lowpass filter for ICA data</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[134]||(e[134]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",W,[i("summary",null,[e[136]||(e[136]=i("a",{id:"EegFun.EogConfig",href:"#EegFun.EogConfig"},[i("span",{class:"jlbinding"},"EegFun.EogConfig")],-1)),e[137]||(e[137]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[139]||(e[139]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EogConfig</span></span></code></pre></div><p>Configuration for EOG (Electrooculogram) channel calculation and detection.</p><p>This type contains all the parameters needed to configure EOG channel calculation and artifact detection, including channel selections and detection criteria.</p><p><strong>Fields</strong></p><ul><li><p><code>vEOG_criterion::Float64</code>: Detection threshold for vertical EOG artifacts (in μV)</p></li><li><p><code>hEOG_criterion::Float64</code>: Detection threshold for horizontal EOG artifacts (in μV)</p></li><li><p><code>vEOG_channels::Vector{Vector{String}}</code>: Channel configuration for vertical EOG [channels1, channels2, output_channel]</p></li><li><p><code>hEOG_channels::Vector{Vector{String}}</code>: Channel configuration for horizontal EOG [channels1, channels2, output_channel]</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[138]||(e[138]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$,[i("summary",null,[e[140]||(e[140]=i("a",{id:"EegFun.EegConfig",href:"#EegFun.EegConfig"},[i("span",{class:"jlbinding"},"EegFun.EegConfig")],-1)),e[141]||(e[141]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[143]||(e[143]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EegConfig</span></span></code></pre></div><p>Configuration for EEG-specific preprocessing settings.</p><p><strong>Fields</strong></p><ul><li><p><code>artifact_value_criterion::Int</code>: Threshold for artifact detection (μV)</p></li><li><p><code>extreme_value_criterion::Int</code>: Threshold for extreme value detection (μV)</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[142]||(e[142]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",J,[i("summary",null,[e[144]||(e[144]=i("a",{id:"EegFun.IcaConfig",href:"#EegFun.IcaConfig"},[i("span",{class:"jlbinding"},"EegFun.IcaConfig")],-1)),e[145]||(e[145]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[147]||(e[147]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IcaConfig</span></span></code></pre></div><p>Configuration for Independent Component Analysis.</p><p><strong>Fields</strong></p><ul><li><p><code>apply::Bool</code>: Whether to apply ICA</p></li><li><p><code>percentage_of_data::Float64</code>: Percentage of data to use for ICA (0-100)</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[146]||(e[146]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",K,[i("summary",null,[e[148]||(e[148]=i("a",{id:"EegFun.PreprocessConfig",href:"#EegFun.PreprocessConfig"},[i("span",{class:"jlbinding"},"EegFun.PreprocessConfig")],-1)),e[149]||(e[149]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[151]||(e[151]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PreprocessConfig</span></span></code></pre></div><p>Comprehensive configuration for EEG data preprocessing.</p><p>This type contains all the parameters needed to configure the complete preprocessing pipeline, including filtering, referencing, artifact detection, and ICA settings.</p><p><strong>Fields</strong></p><ul><li><p><code>reference_channel::Symbol</code>: Reference channel for rereferencing</p></li><li><p><code>epoch_start::Float64</code>: Start time for epoch extraction (seconds)</p></li><li><p><code>epoch_end::Float64</code>: End time for epoch extraction (seconds)</p></li><li><p><code>filter::FilterConfig</code>: Filter configuration</p></li><li><p><code>eog::EogConfig</code>: EOG channel calculation and detection settings</p></li><li><p><code>eeg::EegConfig</code>: EEG-specific preprocessing settings</p></li><li><p><code>ica::IcaConfig</code>: ICA configuration settings</p></li><li><p><code>neighbour_criterion::Float64</code>: Distance criterion (in mm) for channel neighbour definition</p></li></ul>',5)),s(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[150]||(e[150]=[i("a",{href:"https://github.com/igmmgi/EegFun.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[163]||(e[163]=i("h2",{id:"See-Also",tabindex:"-1"},[o("See Also "),i("a",{class:"header-anchor",href:"#See-Also","aria-label":'Permalink to "See Also {#See-Also}"'},"​")],-1)),e[164]||(e[164]=i("ul",null,[i("li",null,[i("a",{href:"./../explanations/data-structures"},"Data structures explanation")])],-1))])}const oe=l(c,[["render",Q]]);export{se as __pageData,oe as default};
