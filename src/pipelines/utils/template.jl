"""
    PipelineTemplateOptions

Configuration options for generating pipeline templates.

# Fields
- `num_steps::Int`: Number of processing steps to generate (default: 5)
- `subsections_per_step::Int`: Number of subsections per step (default: 2)
- `include_usage_example::Bool`: Whether to include usage example comments (default: true)
- `include_setup::Bool`: Whether to include setup section (default: true)
- `include_summary::Bool`: Whether to include summary section (default: true)
"""
struct PipelineTemplateOptions
    num_steps::Int
    subsections_per_step::Int
    include_usage_example::Bool
    include_setup::Bool
    include_summary::Bool
end

PipelineTemplateOptions(;
    num_steps::Int = 5,
    subsections_per_step::Int = 2,
    include_usage_example::Bool = true,
    include_setup::Bool = true,
    include_summary::Bool = true,
) = PipelineTemplateOptions(num_steps, subsections_per_step, include_usage_example, include_setup, include_summary)

# ============================================================================
# Template Section Generators
# ============================================================================

"""
    _generate_header() -> String

Generate the header section of the template.
"""
function _generate_header()
    return """
# Custom EEG Preprocessing Pipeline Template
# Generated by EegFun.generate_pipeline_template()

using EegFun
"""
end

"""
    _generate_function_signature(function_name::String) -> String

Generate the function signature and docstring.
"""
function _generate_function_signature(function_name::String)
    return """
\"\"\"
    $function_name(config::String; log_level::String = "info")

Custom preprocessing pipeline for EEG data.

# Arguments
- `config::String`: Path to the configuration file in TOML format
- `log_level::String`: Log level for preprocessing ("debug", "info", "warn", "error")
\"\"\"
function $function_name(config::String; log_level::String = "info")
"""
end

"""
    _generate_function_preamble(function_name::String) -> String

Generate the function preamble (logging setup, variable initialization).
"""
function _generate_function_preamble(function_name::String)
    return """
    
    # Set up the global log for overall processing
    global_log = setup_global_logging("$function_name.log", log_level = log_level)
    
    # Initialize variables for outer scope
    output_directory = ""
    all_epoch_counts = DataFrame[]  # Vector to store all epoch counts
"""
end

"""
    _generate_setup_section() -> String

Generate the setup section (config loading, file checking, etc.).
"""
function _generate_setup_section()
    return """
    
    try
        @info section("Setup")
        !isfile(config) && @minimal_error "Config file does not exist: \$config"
        cfg = load_config(config)
        cfg == nothing && @minimal_error "Failed to load configuration from: \$config"
        
        # Try and merge user config above with default config
        default_config = load_config(joinpath(@__DIR__, "..", "..", "src", "config", "default.toml"))
        default_config == nothing && @minimal_error "Failed to load default configuration"
        cfg = _merge_configs(default_config, cfg)
        
        # Create the PreprocessConfig object
        preprocess_cfg = PreprocessConfig(cfg["preprocess"])
        
        # Check if all requested raw data files exist
        raw_data_files = get_files(cfg["files"]["input"]["directory"], cfg["files"]["input"]["raw_data_files"])
        raw_data_files_exist = check_files_exist(raw_data_files)
        !raw_data_files_exist && @minimal_error "Missing raw data files requested within TOML file!"
        @info "Found \$(length(raw_data_files)) files: \$(join(raw_data_files, ", "))"
        
        # Read the epoch conditions defined within the toml file
        !isfile(cfg["files"]["input"]["epoch_condition_file"]) && @minimal_error "File missing: \$(cfg["files"]["input"]["epoch_condition_file"])"
        epoch_cfgs = condition_parse_epoch(TOML.parsefile(cfg["files"]["input"]["epoch_condition_file"]))
        @info "Epoch file: \$(cfg["files"]["input"]["epoch_condition_file"]) loaded"
        
        # Find and load layout file
        layout_file = find_file(cfg["files"]["input"]["layout_file"], joinpath(@__DIR__, "..", "..", "data", "layouts"))
        layout_file === nothing && @minimal_error "Layout file not found: \$layout_name"
        layout = read_layout(layout_file)
        
        # Check if requested output directory exists and if not, create it
        output_directory = cfg["files"]["output"]["directory"]
        !isdir(output_directory) && mkpath(output_directory)
        
        # Print config to output directory
        print_config(cfg, joinpath(output_directory, "config.toml"))
        
        # Layout coordinates and calculation of channel neighbours (2D)
        get_neighbours_xy!(layout, cfg["preprocess"]["layout"]["neighbour_criterion"])
        print_layout_neighbours(layout, joinpath(output_directory, "neighbours_xy.toml"))
        
        # ============================================================================
        # CUSTOM PREPROCESSING PIPELINE STARTS HERE
        # ============================================================================
"""
end

"""
    _generate_processing_loop(num_steps::Int, subsections_per_step::Int) -> String

Generate the processing loop with customizable steps and subsections.
"""
function _generate_processing_loop(num_steps::Int, subsections_per_step::Int)
    content = """
        
        # Initialize counters
        processed_files = 0
        failed_files = String[]
        
        for data_file in raw_data_files
            try
                @info section("Processing")
                @info "File: \$data_file"
                
                # Set up per-file logging (temporarily replaces global logger)
                setup_logging(joinpath(output_directory, "\$(basename_without_ext(data_file)).log"), log_level = log_level)
                
                # ========================================================================
                # CUSTOM PROCESSING STEPS
                # ========================================================================
"""

    # Generate steps with subsections
    for step_num = 1:num_steps
        content *= "\n                @info section(\"Step $step_num\")\n"

        for sub_num = 1:subsections_per_step
            content *= "                @info subsection(\"Step $step_num.$sub_num\")\n"
            content *= "                # Your code here...\n"
            if sub_num < subsections_per_step
                content *= "\n"
            end
        end

        if step_num < num_steps
            content *= "\n"
        end
    end

    content *= """
                
                @info section("End of Processing")
                @info "Successfully processed \$data_file"
                processed_files += 1
                
            catch e
                @error "Error processing \$data_file: \$e"
                push!(failed_files, data_file)
            finally
                close_logging()
            end
        end
"""
    return content
end

"""
    _generate_summary_section() -> String

Generate the summary section.
"""
function _generate_summary_section()
    return """
        
        # Write final summary
        @info section("Summary")
        @info "\$processed_files success, \$(length(failed_files)) fail"
        !isempty(failed_files) && @info "Failed files: \$(join(failed_files, ", "))"
"""
end

"""
    _generate_error_handling() -> String

Generate the error handling (catch/finally blocks).
"""
function _generate_error_handling()
    return """
        
    catch e
        @error "Fatal error in preprocessing pipeline: \$e"
        rethrow(e)
    finally
        close_global_logging()
    end
end
"""
end

"""
    _generate_usage_example(function_name::String) -> String

Generate usage example comments.
"""
function _generate_usage_example(function_name::String)
    return """

# ============================================================================
# USAGE EXAMPLE
# ============================================================================

# To use this custom pipeline:
# 1. Modify the sections above to add your specific processing steps
# 2. Update the configuration file as needed
# 3. Run with: $function_name("your_config.toml", log_level = "info")
"""
end

# ============================================================================
# Main Template Generation Function
# ============================================================================

"""
    generate_pipeline_template(
        output_file::String = "custom_pipeline.jl",
        function_name::String = "custom_preprocess";
        options::PipelineTemplateOptions = PipelineTemplateOptions(),
    )

Generate a template file for users to create their own preprocessing pipelines.
The template includes standard setup (logging, config loading, error handling) and
provides a structured framework with sections and subsections for custom processing.

# Why use this?

This function generates a complete preprocessing pipeline template that handles all the
boilerplate code required for a robust EEG preprocessing workflow. Instead of manually
writing repetitive setup code (logging initialization, configuration loading, file
validation, error handling, etc.), you can generate a ready-to-use template that:

- Sets up global and per-file logging with proper error handling
- Loads and validates configuration files (user config + default config merging)
- Checks for required input files and creates output directories
- Initializes layout files and neighbor calculations
- Provides structured sections for your custom processing steps
- Handles errors gracefully with try-catch blocks and proper cleanup
- Generates processing summaries and reports

You can then focus on writing your specific preprocessing logic in the designated sections,
rather than spending time on infrastructure code. The generated template follows best
practices and ensures consistency across different custom pipelines.

# Arguments
- `output_file::String`: Path where the template file should be saved
- `function_name::String`: Name for the main preprocessing function
- `options::PipelineTemplateOptions`: Configuration options for template generation
  - `num_steps::Int`: Number of processing steps to generate (default: 5)
  - `subsections_per_step::Int`: Number of subsections per step (default: 2)
  - `include_usage_example::Bool`: Whether to include usage example comments (default: true)
  - `include_setup::Bool`: Whether to include setup section (default: true)
  - `include_summary::Bool`: Whether to include summary section (default: true)

# Examples
```julia
# Generate a basic template
generate_pipeline_template()

# Generate with custom options
generate_pipeline_template(
    "my_pipeline.jl",
    "my_preprocess";
    options = PipelineTemplateOptions(num_steps = 3, subsections_per_step = 3)
)
```
"""
function generate_pipeline_template(
    output_file::String = "custom_pipeline.jl",
    function_name::String = "custom_preprocess";
    options::PipelineTemplateOptions = PipelineTemplateOptions(),
)
    # Build template from sections
    template_parts = String[]

    # Header
    push!(template_parts, _generate_header())

    # Function signature
    push!(template_parts, _generate_function_signature(function_name))

    # Function preamble
    push!(template_parts, _generate_function_preamble(function_name))

    # Setup section (if enabled)
    if options.include_setup
        push!(template_parts, _generate_setup_section())
    end

    # Processing loop
    push!(template_parts, _generate_processing_loop(options.num_steps, options.subsections_per_step))

    # Summary section (if enabled)
    if options.include_summary
        push!(template_parts, _generate_summary_section())
    end

    # Error handling
    push!(template_parts, _generate_error_handling())

    # Usage example (if enabled)
    if options.include_usage_example
        push!(template_parts, _generate_usage_example(function_name))
    end

    # Combine all parts
    template_content = join(template_parts, "")

    # Write the template to file
    open(output_file, "w") do io
        write(io, template_content)
    end

    @info "Pipeline template generated: $output_file"
    @info "Edit the template to add your custom processing steps"

    return output_file
end
